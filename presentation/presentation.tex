\documentclass{beamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

% Colours for syntax highlighting
\definecolor{syntax_red}{rgb}{0.7, 0.0, 0.0} % For strings
\definecolor{syntax_green}{rgb}{0.15, 0.5, 0.25} % For comments
\definecolor{syntax_purple}{rgb}{0.6, 0.0, 0.45} % For keywords


% Haskell settings for lstlisting
\lstset{language=Haskell,
basicstyle=\ttfamily,
keywordstyle=\color{syntax_purple}\bfseries,
stringstyle=\color{syntax_red},
commentstyle=\color{syntax_green},
numbers=none,
numberstyle=\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false}

\author{
  Beck, Calvin\\
  \href{mailto:hobbes@ualberta.ca}{hobbes@ualberta.ca}
}

\begin{document}

\begin{frame}
  \frametitle{Formal Verification and Coq}
  \maketitle
\end{frame}

\section{Introduction}

\begin{frame}
  \frametitle{What is this Talk about?}

  Formal verification, mostly! This presentation hopes to address the following:

  \begin{itemize}
  \item Why should you care / be interested?
  \item Briefly cover some of the methods.
  \item Make proof assistants more accessible.
  \item Give some rough intuitions about how these systems work.
  \end{itemize}
\end{frame}

\section{Preface}

\begin{frame}[fragile]
  \frametitle{Type Signatures}

  \texttt{x} has type \texttt{A}:
  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true]
    x :: A
  \end{lstlisting}

  \pause

  \texttt{x} is an integer, \texttt{y} is a list of integers.
  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true]
    x :: Integer
    y :: [Integer]
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Signatures Continued...}

  Functions have types too!

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true]
    (+) :: Integer -> Integer -> Integer
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Signatures Continued...}

  Types can also be polymorphic. The identity function, \texttt{id}, may take any type as an argument.

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true]
    id :: a -> a
    id x = x
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lambda Calculus}

  Lambda terms:

  \begin{itemize}
  \item Variables: ``\texttt{x}'' and such
  \item Lambda abstraction: $(\lambda x . t)$ where $t$ is another lambda term. $x$ is an argument, $t$ is the ``body''
  \item Application: $(ts)$
  \end{itemize}

  Combine as you see fit!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Beta Reduction}

  Beta reduction is just substitution.

  \[\mathtt{id} = (\lambda x . x)\]

  Substituting $x$ for $t$...

  \[(\lambda x . x) t = t\]
\end{frame}

\section{Formal Verification: What it be?}

\begin{frame}
  \frametitle{Formal Verification: What it be?}

  The use of formal methods to prove that programs are correct

  \begin{itemize}
  \item<2-> Want programs to be correct
    \begin{itemize}
    \item Almost everything has a computer in it now
    \item Incorrect programs can be dangerous
    \item Bugs can be expensive
    \end{itemize}
  \item<3-> Mathematicians want computers to verify their proofs as well.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Some Methods}

  \begin{itemize}
  \item<1-> Checking by hand... Manual labor :(
  \item<2-> Model checking
    \begin{itemize}
    \item Essentially checking every possible state of your program
    \item ``Proof by exhaustion''
    \item This can be computationally expensive
    \item Works best on small F.S.M.s.
    \end{itemize}
  \item<3-> Type Checking
    \begin{itemize}
    \item Types provide guarantees about how values behave
    \item Most languages do this badly (Java, Python)
    \item Some are good, but still limited (Haskell)
    \end{itemize}
  \item<4-> Theorem Proving
    \begin{itemize}
    \item Mathematical proofs for great justice
    \item Use the computer to check the proofs
    \item This actually boils down to extended type checking
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Levels of Abstraction}

  \begin{itemize}
  \item<1-> High Level: Algorithms? Correct implementation?
  \item<2-> Low Level: Check machine code?
  \item<3-> Hardware?
  \item<4-> Mix and match!
  \end{itemize}

  \onslide<5->

  We'll focus on high level stuff mostly!
\end{frame}

\end{document}
